<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Path Finder</title>
  <link rel="stylesheet" href="node.css">
  <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="text/babel">
    function dijkstra(grid, startNode, finishNode) {
    const visitedNodesInOrder = [];
    startNode.distance = 0;
    const unvisitedNodes = getAllNodes(grid);
    while (!!unvisitedNodes.length) {
      sortNodesByDistance(unvisitedNodes);
      const closestNode = unvisitedNodes.shift();
      // If we encounter a wall, we skip it.
      if (closestNode.isWall) continue;
      // If the closest node is at a distance of infinity,
      // we must be trapped and should therefore stop.
      if (closestNode.distance === Infinity) return visitedNodesInOrder;
      closestNode.isVisited = true;
      visitedNodesInOrder.push(closestNode);
      if (closestNode === finishNode) return visitedNodesInOrder;
      updateUnvisitedNeighbors(closestNode, grid);
    }
    }

    function sortNodesByDistance(unvisitedNodes) {
    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);
    }

    function updateUnvisitedNeighbors(node, grid) {
    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);
    for (const neighbor of unvisitedNeighbors) {
      neighbor.distance = node.distance + 1;
      neighbor.previousNode = node;
    }
    }

    function getUnvisitedNeighbors(node, grid) {
    const neighbors = [];
    const {col, row} = node;
    if (row > 0) neighbors.push(grid[row - 1][col]);
    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);
    if (col > 0) neighbors.push(grid[row][col - 1]);
    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);
    return neighbors.filter(neighbor => !neighbor.isVisited);
    }

    function getAllNodes(grid) {
    const nodes = [];
    for (const row of grid) {
      for (const node of row) {
        nodes.push(node);
      }
    }
    return nodes;
    }

    // Backtracks from the finishNode to find the shortest path.
    // Only works when called *after* the dijkstra method above.
    function getNodesInShortestPathOrder(finishNode) {
    const nodesInShortestPathOrder = [];
    let currentNode = finishNode;
    while (currentNode !== null) {
      nodesInShortestPathOrder.unshift(currentNode);
      currentNode = currentNode.previousNode;
    }
    return nodesInShortestPathOrder;
    }

    const START_NODE_ROW = 10;
    const START_NODE_COL = 9;
    const FINISH_NODE_ROW = 10;
    const FINISH_NODE_COL = 30;
    const createNode = (row, col) =>{
      return {
        row: row,
        col: col,
        isStart: row === START_NODE_ROW && col === START_NODE_COL,
        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,
        distance: Infinity,
        isVisited: false,
        isWall: false,
        previousNode: null,
      };
    };
    const createGrid = () => {
      const grid = []
      for (var row = 0; row < 20; row++){
        const rowlist = []
        for (var col = 0; col < 37; col++) {
          rowlist.push(createNode(row, col));
        }
        grid.push(rowlist);
      }
      return grid;
    };
    const getNewGridWithWallToggled = (grid, row, col) => {
      const newGrid = grid.slice();
      const node = newGrid[row][col];
      const newNode = {
        ...node,
        isWall: !node.isWall,
      };
      newGrid[row][col] = newNode;
      return newGrid;
    }

    class Node extends React.Component {
      render() {
        const {
          row,
          col,
          isStart,
          isFinish,
          isWall,
          onMouseDown,
          onMouseEnter,
          onMouseUp,
        } = this.props;
        const extraClassName = isFinish
        ? 'node-finish'
        : isStart
        ? 'node-start'
        : isWall
        ? 'node-wall'
        : '';

        return (
          <div
            id={`node-${row}-${col}`}
            className={`node ${extraClassName}`}
            onMouseDown={() => onMouseDown(row, col)}
            onMouseEnter={() => onMouseEnter(row, col)}
            onMouseUp={() => onMouseUp()}></div>
        );
      }
    }

    class Pathfinder extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          grid : [],
          mouseIsPressed: false,
        };
      }
s
      componentDidMount() {
        const grid = createGrid();
        this.setState({grid});
      }

      handleMouseDown(row, col) {
        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);
        this.setState({grid: newGrid, mouseIsPressed: true});
      }

      handleMouseEnter(row, col) {
        if (!this.state.mouseIsPressed) return;
        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);
        this.setState({grid: newGrid});
      }

      handleMouseUp() {
        this.setState({mouseIsPressed: false});
      }

      animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {
        for (let i = 0; i <= visitedNodesInOrder.length; i++) {
          if (i === visitedNodesInOrder.length) {
            setTimeout(() => {
              this.animateShortestPath(nodesInShortestPathOrder);
            }, 10 * i);
            return;
          }
          setTimeout(() => {
            const node = visitedNodesInOrder[i];
            if (!((node.row == START_NODE_ROW && node.col == START_NODE_COL) || (node.row == FINISH_NODE_ROW && node.col == FINISH_NODE_COL))) {
              document.getElementById(`node-${node.row}-${node.col}`).className =
                'node node-visited';
            }
          }, 10 * i);
        }
      }

      animateShortestPath(nodesInShortestPathOrder) {
        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {
          setTimeout(() => {
            const node = nodesInShortestPathOrder[i];
            if (!((node.row == START_NODE_ROW && node.col == START_NODE_COL) || (node.row == FINISH_NODE_ROW && node.col == FINISH_NODE_COL))) {
              document.getElementById(`node-${node.row}-${node.col}`).className =
                'node node-shortest-path';
            }
          }, 50 * i);
        }
      }

      visualizeDijkstra() {
        const {grid} = this.state;
        const startNode = grid[START_NODE_ROW][START_NODE_COL];
        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];
        const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);
        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);
        this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);
      }

      render() {
        return (
          <>
            <button onClick={() => this.visualizeDijkstra()}>
              Visualize Dijkstras Algorithm
            </button>
            <div className="grid">
              {this.state.grid.map((row, rowIdx) => {
                return (<div className="" key={rowIdx}>
                  {row.map((node, nodeIdx) => {
                    return (
                      <Node
                        key={nodeIdx}
                        row={node.row}
                        col={node.col}
                        isFinish={node.isFinish}
                        isStart={node.isStart}
                        isWall={node.isWall}
                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}
                        onMouseEnter={(row, col) =>
                          this.handleMouseEnter(row, col)
                        }
                        onMouseUp={() => this.handleMouseUp()}>
                      </Node>
                    );
                  })}
                </div>);
              })}
            </div>
          </>
        );
      }
    }

    ReactDOM.render(
      <Pathfinder />,
      document.getElementById('root')
    );
</script>
</head>

<body>
  <div id="root"></div>
</body>

</html>
